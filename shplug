#!/usr/bin/env sh

# for testing we define vars locally
SHPLUG_DIR=./_shplug/
SHPLUG_SRC=./_shplug/src/
SHPLUG_BIN=./bin/
GIT_HOST="http://github.com"

log() {
    lvl="$1"; shift 1

    echo "$0:$lvl: $*" >&2
}

err() {
    log Err "$@"
}

have() {
    command -v "$1" >/dev/null
}

sed_unbuf() {
    while read -r line; do
        echo "$line" | sed "$@"
    done
}

cursor() {
    case "$1" in
        up)
            printf "\\033[%sA" "$2" ;;
        down)
            printf "\\033[%sB" "$2" ;;
        home)
            printf "\\r" ;;
        clear)
            mode=2
            case "$2" in
                end)   mode=0 ;;
                start) mode=1 ;;
                line)  mode=2 ;;
            esac

            printf "\\033[%sK" "$mode";;
    esac
}

spinner() {
    frames='\|/-'
    while sleep 0.15; do
        frames=$(echo "$frames" | sed 's/\(.\)\(...\)/\2\1/')
        frame=$(echo "$frames" | cut -c1)

        printf '%s %s (%s)\n' "$frame" "$1" "$2"
    done &
    pid=$!

    wait "$2"
    exit_stat=$?
    kill "$pid"
    wait "$pid" 2>/dev/null

    return $exit_stat
}

entry_get() {
    case "$1" in
        id)    index=1 ;;
        short) index=2 ;;
        url)   index=3 ;;
        *)   return 1 ;;
    esac

    echo "$2" | cut -f "$index"
}

read_str() {
    var="$1"; shift
    read -r "$@" <<EOF
$var
EOF
}

# parse_entry() {
#     entry="$1"
#     IFS='	' read_str "$@";
# }

get_path() {
    entry="$1"

    echo "$SHPLUG_SRC/$(entry_get short "$entry" | sed 's/\//:/')"
}

clone() {
    entry="$1"
    # parse_entry "$entry" id=id short_path=shpth url=url rest
    # short_path="$(entry_get short "$entry")"

    url="$(entry_get url "$entry")"
    path="$(get_path "$entry")"

    if [ -d "$path" ]; then
        echo "Directory: '$path' already exists!" >&2
        return 1
    fi
    { mkdir "$path" && cd "$path" ;} ||
        { echo "Directory creation failed!"; return 1; }

    git clone "$url" ./ 1>&2 &
    if spinner "Cloning $short_path" $!; then
        echo "Done clone!"
        return 0
    else
        echo "Failed clone!"
        return 1
    fi
}

is_up_to_date() {
    entry="$1"
    path="$(get_path "$entry")"

    cd "$path" || return 255
    git fetch >&2 &
    spinner "Fetching remote information..." $! ||
        { echo "Error fetching remote info"; return 255; }

    if [ "$(git rev-parse HEAD)" = "$(git rev-parse '@{u}')" ]; then
        return 0
    fi
    return 1
}

fetch() {
    entry="$1"
    path="$(get_path "$entry")"

    cd "$path" &&
        { git fetch >&2 & spinner "Fetching remote information" $! ||
            echo "Error fetching remoote info"; } &&
        { git pull >&2 & spinner "Pulling changes..." $! &&
            echo "Done pulling changes" ||
            echo "Error pulling changes"; }
}

sync() {
    entry="$1"
    shift

    force=$([ "${*#*--force}" != "$*" ] && echo 1)

    url="$(entry_get url "$entry")"
    short_name="$(entry_get short "$entry")"
    id="$(entry_get id "$entry")"

    echo "Synchronizing $short_name..."

    ! [ -n "$force" ] && is_up_to_date "$entry"
    exit_stat=$?


    if [ $exit_stat -eq 0 ]; then
        echo "$short_name is already up to date!"
    elif [ $exit_stat -eq 1 ]; then
        fetch "$entry"
    else
        echo "something went wrong..."
        return 1
    fi

}

register() {
    mkdir -p "$SHPLUG_DIR"
    queue_file="$SHPLUG_DIR/queue"
    touch "$queue_file"

    short_path="$1"

    if ! [ -n "$short_path" ]; then
        err "missing git repository path!"
        exit 1
    else
        git_path="$GIT_HOST/$short_path"
        shift 1
    fi 

    id="$(wc -l "$queue_file" | cut -d' ' -f1)"
    id="$((id + 1))"
    queue_entry="$id	$short_path	$git_path"

    echo "$queue_entry" >> "$queue_file"
}

run() {
    rm -rf "$SHPLUG_DIR/tmp/"
    mkdir -p "$SHPLUG_SRC"
    mkdir -p "$SHPLUG_DIR/tmp/"

    queuefile="$SHPLUG_DIR/queue"
    logfile="$SHPLUG_DIR/log"
    touch "$queuefile"
    rm -f "$logfile"
    touch "$logfile"

    task=$1; shift
    max_id=$(wc -l "$queuefile" | cut -d' ' -f1)

    for _ in $(seq 1 "$max_id"); do
        printf '\n'
    done

    {
        id=
        i=0
        while read -r entry; do
            i=$((i+1))
            {
                { { { { eval "$task \"\$entry\" \"\$@\"" || echo "FAIL:$i">>"$logfile"; } |
                            sed_unbuf "s/^/$i	/"; } 3>&1 1>&2 2>&3 3>&- | # apply sed to stdout
                            sed_unbuf "s/^/$i	/"; } 3>&1 1>&2 2>&3 3>&-   # apply sed to stderr
                } 2>>"$logfile";

                if ! grep -q "^FAIL:$i\$" "$logfile"; then
                    printf 'success	%s\n' "$i"
                else
                    printf 'fail	%s\n' "$i"
                fi
            } &
        done < "$queuefile"
    } | {
        log_len=0
        padding=1
        # for _ in $(seq 1 $padding); do printf '\n'; done
        printf -- '  ────────────────\n'

        while IFS='	' read -r pre post; do
            if echo "$pre" | grep -Eq '^[0-9]+$'; then
                id="$pre"; status="$post"
                short_path="$(sed -n "${id}p" "$queuefile" | cut -f2)"

                cur_stat=$(printf "(%s/%s) %-20s	%s" "$id" "$max_id" "$short_path" "$status")
                # eval "stat_$id='$cur_stat'"

                lines_up=$(((max_id + 1 - id) + padding + log_len))

                printf "%s" "$(
                    cursor up $lines_up
                    cursor clear line
                    printf "%s" "$cur_stat"
                    # cursor clear end
                    cursor home
                    cursor down $lines_up
                )"
            else
                exit_stat="$pre"; id="$post"
                short_path="$(sed -n "${id}p" "$queuefile" | cut -f2)"

                case "$exit_stat" in

                    success)
                        ;;

                    fail)
                        printf '(%s) %s failed:\n' "$id" "$short_path"
                        log_len=$((log_len + 1))
                        while read -r iid line; do
                            if [ "$iid" = "$id" ]; then
                                printf '	%s\n' "$line"
                                log_len=$((log_len + 1))
                            fi
                        done <"$logfile"
                        ;;
                esac
            fi
        done
    }
}

case "$1" in
    run)
        if ! have git; then
            err "command: \`git\` is missing!"
            exit 1
        fi
        shift 1
        run "$@"
        ;;
    clean)
        rm -rf "$SHPLUG_SRC"
        ;;
    *)
        register "$@"
        ;;
esac

# if [ "$1" = "load" ]; then
#     if ! have git; then
#         err "command: \`git\` is missing!"
#         exit 1
#     fi
#     shift 1
#     load "$*"
# else
#     register "$*"
# fi





