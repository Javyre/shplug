#!/usr/bin/env sh

# for testing we define vars locally
SHPLUG_DIR=./_shplug/
SHPLUG_SRC=./_shplug/src/
SHPLUG_BIN=./bin/
GIT_HOST="http://github.com"

log() {
    lvl="$1"; shift 1

    echo "$0:$lvl: $*" >&2
}

err() {
    log Err "$@"
}

have() {
    command -v "$1" >/dev/null
}

sed_unbuf() {
    while read -r line; do
        echo "$line" | sed "$@"
    done
}

cursor() {
    case "$1" in
        up)
            printf "\\033[%sA" "$2" ;;
        down)
            printf "\\033[%sB" "$2" ;;
        home)
            printf "\\r" ;;
        clear)
            mode=2
            case "$2" in
                end) mode=0 ;;
                start) mode=1 ;;
                line) mode=2 ;;
            esac

            printf "\\033[%sK" "$mode";;
    esac
}

spinner() {
    frames='\|/-'
    while sleep 0.15; do
        frames=$(echo "$frames" | sed 's/\(.\)\(...\)/\2\1/')
        frame=$(echo "$frames" | cut -c1)

        printf "%s %s (%s)\\n" "$frame" "$1" "$2"
    done &
    pid=$!

    wait "$2"
    exit_stat=$?
    kill "$pid"
    wait "$pid" 2>/dev/null
    
    return $exit_stat
}

clone() {
    cd "$SHPLUG_SRC" && git clone "$1" 1>&2 &
    if spinner "Cloning $1" $!; then
        echo "Done clone!"
        return 0
    else
        echo "Failed clone!"
        return 1
    fi
}

register() {
    mkdir -p "$SHPLUG_DIR"

    if ! [ -n "$1" ]; then
        err "missing git repository path!"
        exit 1
    else
        git_path="$GIT_HOST/$1"
        shift 1
    fi

    queue_entry="$git_path	&"

    touch "$SHPLUG_DIR/queue"
    echo "$queue_entry" >> "$SHPLUG_DIR/queue"
}

load() {
    rm -rf "$SHPLUG_DIR/tmp/"
    mkdir -p "$SHPLUG_SRC"
    mkdir -p "$SHPLUG_DIR/tmp/"

    queuefile="$SHPLUG_DIR/queue"
    logfile="$SHPLUG_DIR/log"
    touch "$queuefile"
    rm -f "$logfile"
    touch "$logfile"

    max_id=$(wc -l "$queuefile" | cut -d' ' -f1)

    for _ in $(seq 1 "$max_id"); do
        printf '\n'
    done

    {
        id=
        i=0
        while read -r entry; do
            i=$((i+1))
            {
                { { { { clone "$(echo "$entry" | cut -f1)" || echo "FAIL:$i">>"$logfile"; } |
                            sed_unbuf "s/^/$i	/"; } 3>&1 1>&2 2>&3 3>&- | # apply sed to stdout
                            sed_unbuf "s/^/$i	/"; } 3>&1 1>&2 2>&3 3>&-   # apply sed to stderr
                } 2>>"$logfile"; 

                if ! grep -q "FAIL:$i" "$logfile"; then
                    printf 'success	%s\n' "$i"
                else
                    printf 'fail	%s\n' "$i"
                fi
            } &
        done < "$queuefile"
    } | {
        log_len=0
        padding=1
        # for _ in $(seq 1 $padding); do printf '\n'; done
        printf -- '  ────────────────\n'

        while IFS='	' read -r pre post; do
            if echo "$pre" | grep -Eq '^[0-9]+$'; then
                id="$pre"; status="$post"

                cur_stat=$(printf "%s/%s .... %s" "$id" "$max_id" "$status")
                # eval "stat_$id='$cur_stat'"

                lines_up=$(((max_id + 1 - id) + padding + log_len))

                printf "%s" "$(
                    cursor up $lines_up
                    printf "%s" "$cur_stat"
                    cursor clear end
                    cursor home
                    cursor down $lines_up
                )"
            else
                exit_stat="$pre"; id="$post"

                case "$exit_stat" in

                    success)
                        ;;

                    fail)
                        printf '%s failed:\n' "$id"
                        log_len=$((log_len + 1))
                        while read -r iid line; do
                            if [ "$iid" = "$id" ]; then 
                                printf '	%s\n' "$line"
                                log_len=$((log_len + 1))
                            fi
                        done <"$logfile"
                        ;;
                esac
            fi
        done
    }
}

case "$1" in
    load)
        if ! have git; then
            err "command: \`git\` is missing!"
            exit 1
        fi
        shift 1
        load "$*"
        ;;
    clean)
        rm -rf "$SHPLUG_SRC"
        ;;
    *)
        register "$*"
        ;;
esac

# if [ "$1" = "load" ]; then
#     if ! have git; then
#         err "command: \`git\` is missing!"
#         exit 1
#     fi
#     shift 1
#     load "$*"
# else
#     register "$*"
# fi





