#!/usr/bin/env sh

### Environment configuration

# $SHPLUG_HOME is handled by init.sh
if [ -z "$SHPLUG_HOME" ]; then
    echo '$SHPLUG_HOME has not been exported. Aborting.' >&2
    exit 1
fi

readonly SHPLUG_BIN="$SHPLUG_HOME"/bin # user programs
readonly SHPLUG_DB="$SHPLUG_HOME"/db

readonly COLOUR_RED='\033[91m'
readonly COLOUR_GREEN='\033[92m'
readonly COLOUR_RESET='\033[0m'

### Utility functions
have() {
    command -v "$1" >/dev/null
}

err() {
    echo "$@" >&2
}

success() {
    printf '%s%s%s\n' "$COLOUR_GREEN" "$*" "$COLOUR_RESET"
}

failure() {
    printf '%s%s%s\n' "$COLOUR_RED" "$*" "$COLOUR_RESET"
}

sed_unbuf() {
    while read -r line; do
        echo "$line" | sed "$@"
    done
}

http_get() {
    { have wget && wget -qO- "$1"; } ||
    { have curl && curl -s "$1"; }
}

http_download() {
    { have wget && wget -q "$1"; } ||
    { have curl && curl -sO "$1"; }
}

# Pipe to two programs at once
# stderr goes into $ERR and stdout into $OUT
# NOTE: UNUSED
fd_apply() {
    {
        eval "$@" 3>&1 1>&2 2>&3 |
        eval "${ERR:-cat}"

    } 3>&1 1>&2 2>&3 3>&- |

    eval "${OUT:-cat}"
}

cursor() {
    case "$1" in
        up)
            printf "\\033[%sA" "$2" ;;
        down)
            printf "\\033[%sB" "$2" ;;
        home)
            printf "\\r" ;;
        clear)
            mode=2
            case "$2" in
                end)   mode=0 ;;
                start) mode=1 ;;
                line)  mode=2 ;;
            esac

            printf "\\033[%sK" "$mode";;
    esac
}

# NOTE: UNUSED
escape_rgx() {
    echo "$1" | sed 's/[^^]/[&]/g; s/\^/\\^/g'
}

extract() {
    archive_path="$1"
    archive_name="$(basename -- "$archive_path")"
    archive_ext="$(echo "$archive_name" | sed 's/.*\.\([0-9a-zA-Z.]\+\)/\1/')"

    eval "extract__$archive_ext"' $@'
}

extract__tgz() { 
    archive_path="$1"
    target_path="$2" 

    mkdir -p "$target_path"
    tar -xvzf "$archive_path" -C "$target_path"
}

spinner() {
    frames='\|/-'
    while sleep 0.15; do
        frames=$(echo "$frames" | sed 's/\(.\)\(...\)/\2\1/')
        frame=$(echo "$frames" | cut -c1)

        printf '%s %s\n' "$frame" "$1"
    done &
    pid=$!

    wait "$2"
    exit_stat=$?
    kill "$pid"
    wait "$pid" 2>/dev/null

    return $exit_stat
}

entry_get() {
    param="$1"
    entry="$ENTRY"

    case "$param" in
        short|from|use|at|post|url|path)
            . "$entry"
            eval "echo \"\$$param\""
            ;;
        rename-to)
            . "$entry"
            echo "$rename_to"
            ;;
        entry-path)
            dirname "$entry"
            ;;
        *)
            return 1
            ;;
    esac
}

read_str() {
    var="$1"; shift
    read -r "$@" <<EOF
$var
EOF
}

forward_fun() {
    fun="$1"; shift 1

    from="$(entry_get from)"
    eval "$(echo "$from" | sed 's/-/_/')__${fun} \"\$@\""
}

is_cloned() {
    path="$(entry_get path)"
    [ -d "$path" ] && [ -n "$(ls -qAL -- "$path")" ]
}

# subshell since it performs some `cd`s
clone() (
    url="$(entry_get url)"
    path="$(entry_get path)"

    if is_cloned; then
        err "Directory: '$path' already exists!"
        err "Assuming package has already been cloned"
        success "Already cloned"
        return 0
    fi 

    if ! mkdir -p "$path" && cd "$path"; then
        err "Failed to create directory '$path'"
        failure "Directory creation failed"
        return 1
    fi

    case "$(entry_get from)" in
        gh)
            git clone "$url" "$path" >&2
            ;;
        gh-r)
            http_download "$url" >&2
            ;;
    esac &

    if spinner "Cloning $short_path" $!; then
        success "Done clone"
        return 0
    else
        failure "Failed clone"
        return 1
    fi
)

is_up_to_date() (
    forward_fun is_up_to_date
)

gh__is_up_to_date() {
    # entry="$1"
    path="$(entry_get_path)"

    cd "$path" || return 255
    git fetch >&2 &
    spinner "Fetching remote information..." $! ||
        { echo "Error fetching remote info"; return 255; }

    if [ "$(git rev-parse HEAD)" = "$(git rev-parse '@{u}')" ]; then
        return 0
    fi
    return 1
}

gh_r__is_up_to_date() {
    return 1
}

fetch() ( forward_fun fetch "$@"; )

gh__fetch() {
    path="$(entry_get_path)"
    at="$(entry_get at)"

    if ! [ "$at" = "latest" ]; then
        #FIXME: Implement `at` tag
        echo
    fi

    cd "$path" &&
    {
        git fetch >&2 &
        spinner "Fetching remote information" $! ||
        echo "Error fetching remoote info"
    } &&
    {
        git pull >&2 &
        spinner "Pulling changes..." $! &&
        echo "Done pulling changes" ||
        echo "Error pulling changes"
    }
}

gh_r__fetch() {
    path="$(entry_get_path)"

    rm -rf "$path"
    clone "$@"
}

sync() {
    [ -n "$ENTRY" ] || { echo "entry is null" >&2; return 255; }

    force=$([ "${*#*--force}" != "$*" ] && echo 1)

    short_name="$(entry_get short)"

    echo "Synchronizing $short_name..."

    if ! is_cloned; then
        clone
    else
        [ -z "$force" ] && is_up_to_date
        exit_stat=$?


        if [ $exit_stat -eq 0 ]; then
            echo "$short_name is already up to date!"
        elif [ $exit_stat -eq 1 ]; then
            fetch "$ENTRY"
        else
            echo "something went wrong..."
            return 1
        fi
    fi

}

install() {
    echo "Making sure the bin folder is present..."
    mkdir -p "$SHPLUG_BIN" || return 255
    forward_fun install "$@"
}

gh_r__install() (
    # entry="$1"
    path="$(entry_get path)"

    cd "$path" || return 255

    archive_name="$(basename -- "$(find . | sed -n '2p')")"
    extract "$archive_name" "extracted" >&2 &
    spinner "Extracting package..." $! || { echo "Failed to extract package!"; return 255; }
    echo "Done extracting package"

    bin_name="$(basename -- "$(find ./extracted | sed -n '2p')")"

    new_name="$(entry_get rename-to)"
    new_name="${new_name:-$bin_name}"

    ln -s \
        "$PWD/extracted/$bin_name" \
        "$SHPLUG_BIN/$new_name"

    echo "Done installation"

    # archive_ext="$(echo "$archive_name" | sed 's/.*\.\([0-9a-zA-Z.]\+\)/\1/')"

    # eval "extract__$archive_ext"' $archive_name extracted'
)

gh__install() (
    # entry="$1"
    path="$(entry_get path)"

    cd "$path" || return 255

    #run installation command
    sh -c "$(entry_get hook-build)" >&2 &
    spinner "Running build hook..." $! || { echo "Build hook failed!"; return 255; }
    echo "Done running build hook"


    pat="$(entry_get use)"
    pat_e="$(echo "$pat" | sed 's/\//\\\//g')"
    new_name="$(entry_get rename-to)"
    printf  'bin name: %s\n' "$new_name" >&2

    # if [ -n "$new_name" ]; then
        find . | sed -n '/^\.\/'"$pat_e"'$/p' |
            while read -r match; do
                if [ -n "$new_name" ]; then
                    printf  'bin name: %s\n' "$new_name" >&2
                    ln -s \
                        "$PWD/$match" \
                        "$SHPLUG_BIN/$(
                            echo "$match" |
                            sed 's/^\.\/'"$pat_e"'$'"/$new_name/"
                        )" >&2 ||
                    return 255
                else
                    ln -s \
                        "$PWD/$match" \
                        "$SHPLUG_BIN" >&2 ||
                    return 255
                fi

            done

    echo "Done installation"
)

get_param() {
    tag="$1"; shift 1
    for arg in "$@"; do
        param="$(echo "$arg" | sed -n 's/^'"$tag"':\(.*\)$/\1/p')"
        if [ -n "$param" ]; then
            echo "$param"
            return 0
        fi
    done
    return 1
}

register() {
    short_path="$1"; shift

    if [ -z "$short_path" ]; then
        err "missing repository url!"
        exit 1
    fi

    from="$(      get_param from       "$@" || echo gh)"
    rename_to="$( get_param rename-to  "$@" || :)"
    at="$(        get_param at         "$@" || echo latest)"
    post="$(      get_param hook-build "$@" || echo :)"

    case "$from" in
        gh)
            use='\[^/\]*\.sh'
            url="https://github.com/$short_path"
            ;;
        gh-r)
            use='linux.*64'
            url="https://api.github.com/repos/$short_path/releases"
            ;;
    esac

    entry_path="$SHPLUG_DB/$short_path"
    mkdir -p "$entry_path"

cat << EOF > "$entry_path/ENTRY"
use='$use'
from='$from'
rename_to='$rename_to'
at='$at'
post='$post'
short='$short_path'
url='$url'
path='$entry_path/repo'
EOF
}

# Task runs the given task for the provided $ENTRY.
# All output of task must be prefixed by $out_prefix,
# that is, the id, and the current $ENTRY.
# This is so that the caller of task can properly handle
# task's output.
task() {
    task="$1"; shift

    # get name for logfile
    entry_path="$(entry_get entry-path)"
    logfile="$entry_path/err.log"

    eval "$task" "$@" 2> "$logfile"
    exitcode=$?

    return "$exitcode"

    #OUT="sed_unbuf 's/^/$id	stat	/'"          \
    #ERR="sed_unbuf 's/^/$id	/'"                  \
        #fd_apply                                 \
            #eval "$task" "$@"               "&&" \
            #echo "SUCCESS:$id" ">>$LOGFILE" "||" \
            #echo "FAIL:$id"    ">>$LOGFILE"      \
        #2>>"$LOGFILE"

    #{
        #short_path="$(entry_get short)"
        #succ="$(grep -q "^SUCCESS:$id\$" "$LOGFILE" && echo t)"
        #fail="$(grep -q "^FAIL:$id\$"    "$LOGFILE" && echo t)"

        #if [ -n "$SHPLUG_DEBUG""$succ" ] || [ -n "$fail" ] ; then
            #[ -n "$succ" ] && { stat=succeded color="$GRN"; }
            #[ -n "$fail" ] && { stat=failed   color="$RED"; }

            #printf '%s(%s) %s %s:%s\n' \
                #"$color"               \
                #"$id"                  \
                #"$short_path"          \
                #"$stat"                \
                #"$RST"

            #sed -n 's/'"$id"'	\(.*\)/	\1/p' < "$LOGFILE"
        #fi
    #} | sed "s/^/$id	log	/"
}

run() {
    task=$1; shift

    # find creates a list of every entry inside the db,
    # since every entry is a file named ENTRY.
    entry_list="$(find "$SHPLUG_DB" -type f -name 'ENTRY')"
    max_ln="$(echo "$entry_list" | wc -l)"

    # allocate a new line for each entry
    i=0
    while [ "$i" -lt "$max_ln" ]; do
        i=$(( i + 1 ))
        echo
    done
    unset i

    echo "$entry_list" |
    nl -b a -n ln |
    {
        # Begin a subprocess for each entry.
        # Piping makes synchronisation easy.
        while read -r ln entry; do
            # Prefix the output of task with the line number
            # followed by a tab character.
            ENTRY="$entry" \
                task "$task" "$@" |
                sed_unbuf "s/^/$ln	/"&
        done
    } | {
        log_len=0

        padding=1
        printf -- '  ────────────────\n' # padding

        # IFS is a tab character.
        while IFS='	' read -r ln msg; do
            ENTRY="$(echo "$entry_list" | head -n "$ln" | tail -n 1)"

            short_path="$(entry_get short)"

            cur_stat="$(
                printf '(%s/%s) %-20s\t%s' \
                    "$ln"                   \
                    "$max_ln"               \
                    "$short_path"           \
                    "$msg"                  \
            )"

            lines_up=$(((max_ln + 1 - ln) + padding + log_len))

            printf "%s" "$(
                cursor up "$lines_up"
                cursor clear line
                printf "%s" "$cur_stat"
                cursor home
                cursor down "$lines_up"
            )"

            #id="$(echo "$line" | cut -f1)"
            #mode="$(echo "$line" | cut -f2)"
            #msg="$(echo "$line" | cut -f3-)"

            #if [ "$mode" = stat ]; then
                #ENTRY="$(sed -n "${id}p" "$queuefile")"

                #short_path="$(entry_get short)"

                #cur_stat="$(
                    #printf "(%s/%s) %-20s	%s" \
                        #"$id"                   \
                        #"$max_id"               \
                        #"$short_path"           \
                        #"$msg"                  \
                #)"

                #lines_up=$(((max_id + 1 - id) + padding + log_len))

                #printf "%s" \
                    #"$(
                        #cursor up $lines_up
                        #cursor clear line
                        #printf "%s" "$cur_stat"
                        ## cursor clear end
                        #cursor home
                        #cursor down $lines_up
                    #)"

            #elif [ "$mode" = log ]; then
                #ENTRY="$(sed -n "${id}p" "$queuefile")"
                #printf '%s: %s\n' "$(entry_get rename-to)" "$msg"
                #log_len=$((log_len + 1))
            #fi
        done
    }
}

case "$1" in
    run)
        if ! have git; then
            err "command: \`git\` is missing!"
            exit 1
        fi
        shift 1
        run "$@"
        ;;
    load)
        err 'Unimplemented'; exit 1
        ;;
    clean)
        err 'Unimplemented'; exit 1
        ;;
    *)
        register "$@"
        ;;
esac

